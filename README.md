# ОТЧЁТ
## Постановка задачи - разбор алгебраического выражения при помощи стека
> [!NOTE]
> Множества
> 1. символов 'a'  - 'z', '0' - '9';
> 2. операций '+','-','*','/'  '(',')';

### РЕШЕНИЕ И АЛГОРИТМ
При проверке правильности выражения, мы не учитываем приоритет операций.
Мы помещаем выражение в стек, пока не встретим закрывающуюся скобку ")".
Далее мы проверяем корректность того, что находится в скобках, заменяя на новый символ из 'a' - 'z' или '0' - '9'.
По итогу, вы проверяем итоговое выражение, которое поулчилось псоле прохождения всего выражения и замен.

## СТЕК
> [!NOTE]
> Стек (от англ. stack — стопка) — структура данных, представляющая собой упорядоченный набор элементов, в которой добавление новых элементов и удаление существующих производится с одного конца, называемого вершиной стека.

```C
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <ctype.h>
```
При выполнении этого проекта я использовал библиотеки, представленные выше.


Эти определения структур нужны для реализации стека как связного списка.
```C
typedef struct node {
    char data; // Данные узла, в данном случае символ (char)
    struct node *next;  // Указатель на следующий узел в стеке
} node;
```

```C
typedef struct stack {
    struct node *top; // Указатель на вершину стека (последний добавленный элемент)
    int size; // Текущий размер стека (количество элементов)
} stack;
```
Также для реализации данного проекта необходимы следующие функции:

> [!NOTE]
> 1. Push - положить в вершину
> 2. Pop - вытащить из верщины
> 3. ShowTop - показать вершину стека
> 4. PrintStack - вывод стека
> 5. IsEmpty - проверка на пустоту
> 6. DeleteStack - удаление стека полностью

Давайте рассмотрим каждую из них более подробно.

> [!NOTE]
> Функция Push необходима для добавления нового элемента в стек. Это одна из базовых операций для работы со стеком, реализующим принцип LIFO (Last In, First Out — последний вошёл, первый вышел).

1. Push - положить в вершину
```C
bool Push(stack *st, char data)
{
    if (st == NULL) // Проверяем, передан ли корректный указатель на стек
        return false;

    // Выделяем память для нового элемента стека
    node *newElem = (node *)malloc(sizeof(node));

    if (newElem) // Проверяем, удалось ли выделить память
    {
        newElem->data = data;// Записываем данные в новый элемент
        newElem->next = NULL;// Изначально указатель на следующий элемент равен NULL
        
        if (st->top) // Если стек не пуст
            newElem->next = st->top; // Новый элемент указывает на текущий верхний элемент

        st->top = newElem;// Новый элемент становится вершиной стека
        st->size++;// Увеличиваем размер стека
    }
    else
        return false;// Если память не выделилась, возвращаем false

    return true;// Успешно добавили элемент в стек
}
```

> [!NOTE]
> Функция Pop необходима для удаления верхнего элемента из стека и возврата его данных. Также является одной из ключевых функций для работы со стеком.

2. Pop - вытащить из верщины
```C
char Pop(stack *st)
{
    if (st == NULL) // Проверяем, передан ли корректный указатель на стек
        return 0;

    // Если стек не пуст
    if (st->top)
    {
        node *tmp = st->top;// Сохраняем указатель на текущую вершину стека
        st->top = st->top->next;// Обновляем вершину стека на следующий элемент

        char data = tmp->data;// Сохраняем данные текущей вершины
        free(tmp);// Освобождаем память, занятую удаляемым элементом
        st->size--;// Уменьшаем размер стека
        return data;// Возвращаем данные удалённого элемента
    }

    return 0; // Если стек пуст, возвращаем 0
}
```


> [!NOTE]
> Функция ShowTop используется для получения данных верхнего элемента стека, не удаляя его. Это значит, что она позволяет заглянуть в вершину стека и извлечь её данные, но не изменяет структуру стека.

3. ShowTop - показать вершину стека
```C
bool ShowTop(stack st, char *data)
{
    if (data == NULL) // Проверяем, передан ли корректный указатель для хранения данных
        return false;

    if (st.top) // Проверяем, не пуст ли стек (есть ли вершина)
    {
        *data = st.top->data; // Сохраняем данные из верхнего элемента стека в переданный указатель
        return true;// Успешно получили данные
    }

    return false; // Если стек пуст, возвращаем false
}
```


> [!NOTE]
> Функция PrintStack нужна для вывода всех элементов стека на экран. Она позволяет визуализировать содержимое стека, что может быть полезно для отладки или для отображения данных в программе.

4. PrintStack - вывод стека
```C
void PrintStack(stack st)
{
    if (st.top) // Проверяем, не пуст ли стек (есть ли элементы)
    {
        node *current = st.top; // Указатель на текущий элемент стека, начинаем с вершины

        // Перебираем все элементы стека, начиная с вершины
        while (current)
        {
            printf("%c\n", current->data); // Выводим данные текущего элемента
            current = current->next; // Переходим к следующему элементу в стеке
        }

    }
    else
        printf("Stack is empty!\n"); // Если стек пуст, выводим соответствующее сообщение
}
```


> [!NOTE]
> Функция IsEmpty предназначена для проверки, пуст ли стек. Это важная операция, которая позволяет безопасно работать со стеком, особенно перед выполнением операций, таких как удаление элементов, чтобы избежать ошибок, связанных с попыткой работы с пустой структурой данных.

5. IsEmpty - проверка на пустоту
```C
bool IsEmpty(stack st)
{
    if (st.top) // Если вершина стека указывает на элемент (стек не пуст)
        return false; // Стек не пуст, возвращаем false
    
    return true; // Если вершина стека равна NULL, значит стек пуст, возвращаем true
}
```


> [!NOTE]
> Функция DeleteStack предназначена для очистки стека, т.е. для удаления всех элементов стека и освобождения памяти, занятой этими элементами. После её выполнения стек становится пустым, а вся память, которая была выделена под элементы стека, освобождается.

6. DeleteStack - удаление стека полностью
```C
void DeleteStack(stack *st)
{
    if (st == NULL) // Проверяем, что передан корректный указатель на стек
        return; // Если указатель на стек равен NULL, ничего не делаем

    // Если стек не пустой, продолжаем очистку
    if (st->top)
    {
        node *current = st->top; // Инициализируем указатель на первый элемент стека
        
        // Проходим по всем элементам стека
        while (current)
        {
            node *tmp = current;// Сохраняем текущий элемент в tmp
            current = current->next;// Переходим к следующему элементу в стеке

            free(tmp);// Освобождаем память, занятую текущим элементом
            st->size--;// Уменьшаем размер стека
        }

        st->top = NULL; // После удаления всех элементов, указываем на NULL, чтобы стек был пустым
    }
}
```

## ГЛАВНАЯ ФУНКЦИЯ ПРОВЕРКИ ВЫРАЖЕНИЯ

> [!NOTE]
> 1. Проверка данных
> 2. Помещение символов в стек до символа ")"
> 3. Проверка выражения в скобках и замена на один элемент
> 4. Проверка выражения которое осталось по итогу (без скобок)
> 5. В конце проверка размера стека, если ноль то выражение верно, иначе не верно

 Функция CheckLexeme предназначена для проверки корректности последовательности символов в стеке, который представляет собой выражение, состоящее из операндов (например, цифр или букв) и операторов (например, +, -, *, /).

```C
bool CheckLexeme(stack *st)
{
    if (st == NULL) // Проверка на корректность указателя на стек
        return false; // Если стек не был передан, возвращаем false

    int i = 0; // Индикатор позиции символа в выражении (через него отслеживаем порядок операндов и операторов)

    // Пока стек не пуст, продолжаем проверку
    while (!IsEmpty(*st))
    {
        char tmp = Pop(st); // Извлекаем верхний элемент стека

        // Если на 2-й позиции стоит операнд (цифра или буква), выражение неправильное
        // Позиции: 0 - первый, 1 - второй, 2 - третий, и так далее
        if (IsNumber(tmp) || IsLetter(tmp))
            if (i == 1) // Проверка для второй позиции (индекс 1)
                return false; // Если на второй позиции операнд, выражение некорректно

        // Если на 1-й или 3-й позиции стоит оператор, выражение неправильное
        // Операторы не могут стоять на позиции 0 или 2
        if (IsOperator(tmp))
            if (i == 0 || i == 2) // Проверка для первой (i == 0) и третьей (i == 2) позиций
                return false; // Если на этих позициях оператор, выражение некорректно
        
        i++; // Переходим к следующей позиции
    }

    return true; // Если выражение прошло все проверки, возвращаем true
}
```
Итоговая функция, выполняющая проверку всего выражения

```C
bool ExpressionValid(char *expression)
{
    if (expression == NULL) // Проверяем, что передано корректное выражение
        return false; // Если выражение NULL, возвращаем false
    
    stack brackets = {NULL, 0}; // Стек для проверки парных скобок
    stack st = {NULL, 0}; // Стек для хранения операндов и операторов
    bool flag = true; // Флаг, который отслеживает, является ли текущий символ операндом

    // Проходим по каждому символу выражения
    for (int i = 0; expression[i]; i++)
    {
        if (expression[i] == '(') // Если встретили открывающую скобку
        {
            flag = true; // Ставим флаг в true, ожидаем операнд перед закрывающей скобкой

            char top;
            // Проверяем, что перед открывающей скобкой нет операнда
            if (ShowTop(st, &top))
            {
                if (!IsOperator(top)) // Если сверху стека не оператор, выражение некорректно
                    return false;
            }
            Push(&brackets, '('); // Добавляем открывающую скобку в стек
        }
        else if (expression[i] == ')') // Если встретили закрывающую скобку
        {
            char top;
            // Проверяем, что перед закрывающей скобкой нет оператора
            if (ShowTop(st, &top))
            {
                if (IsOperator(top)) // Если перед закрывающей скобкой стоит оператор, выражение некорректно
                    return false;
            }

            if (IsEmpty(brackets)) // Если нет открывающей скобки для пары, выражение некорректно
                return false;
            
            Pop(&brackets); // Убираем открывающую скобку из стека
        }
        else if (expression[i] != ' ') // Если не пробел, то это либо операнд, либо оператор
        {
            // Если ожидается операнд (например, перед оператором или открывающей скобкой), добавляем '0'
            if (flag && (expression[i] == '-' || expression[i] == '+'))
                Push(&st, '0');

            Push(&st, expression[i]); // Добавляем текущий символ в стек

            flag = false; // Теперь после операнда можно ожидать оператор
        }
    }

    // Если стек для выражения пуст или остались открытые скобки, выражение некорректно
    if (IsEmpty(st))
        return false;
    if (!IsEmpty(brackets))
        return false;

    flag = true; // Флаг для дальнейшей проверки лексем

    // Проходим по выражению с использованием стека для лексем
    while (flag)
    {
        stack lexeme = {NULL, 0}; // Стек для хранения лексем

        // Формируем лексему (по три символа)
        for (int i = 0; i < 3; i++)
        {
            char tmp = Pop(&st); 
            if (tmp)
                Push(&lexeme, tmp); // Добавляем символ в стек лексем
        }

        // Если лексема корректна, заменяем её на один символ 'r'
        if (CheckLexeme(&lexeme))
            Push(&st, 'r'); // Успешно проверена лексема
        else
            return false; // Если лексема некорректна, выражение некорректно

        // Если в стеке остался только один элемент, завершаем цикл
        if (st.size == 1)
            flag = false;
    }

    return true; // Выражение корректно
}
```
## ТЕСТИРОВКА ПРОГРАММЫ НА РАЗЛИЧНЫХ ВЫРАЖЕНИЯХ
 
Я рассмотрел всевозможные случаи выражений, которые могут встретиться, они могут быть как коректны, так и нет
```C
//char *str = ""; // Некорректно
//char *str = "(-1)()"; // Некорректно
//char *str = "a + c * ()"; // Некорректно
//char *str = "((-2) - 2)"; // Корректно
//char *str = "( +9 - ((-1) / a ) + (c /  (-3)))"; // Корректно
//char *str = "(a + (b**Z) - 3)"; // Некорректно
//char *str = "((a + 1) / Z) - 9"; // Корректно
//char *str = "+1"; // Некорректно
//char *str = "()"; // Некорректно
//char *str = "(-6)"; // Корректно
//char *str = "(+6)"; // Корректно
//char *str = "(+1 - (-2 - (-3 - (-4 - (-5 - 6)))))"; // Корректно
//char *str = "(-1 - (-2 - (-3 - (-4 - (-5 - 6)))))"; // Корректно
//char *str = "(-1 - (-2 - (3 - 4) - 4) - 5)"; // Корректно
//char *str = "1 - (-1) - (-3)"; // Корректно
//char *str = "1 - (-1) - (-3)"; // Корректно
//char *str = "1 - - - 3"; // Некорректно
//char *str = "-3"; // Корректно
//char *str = "a + b * c / 1 - 9"; // Корректно
```

Выше приведены различные ситуации, которые могут быть найдены и проверены при помощи нашего проекта
